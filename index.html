<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DICOM Viewer - Tags Display</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .upload-section {
            padding: 40px;
            text-align: center;
            border-bottom: 2px solid #f0f0f0;
        }

        .mode-switch {
            padding: 20px 40px;
            background: #f8f9ff;
            border-bottom: 2px solid #f0f0f0;
            display: flex;
            gap: 10px;
            justify-content: center;
            align-items: center;
        }

        .mode-btn {
            padding: 10px 25px;
            border: 2px solid #667eea;
            background: white;
            color: #667eea;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s ease;
        }

        .mode-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .mode-btn:hover:not(.active) {
            background: #f0f2ff;
        }

        .compare-section {
            padding: 40px;
            display: none;
            border-bottom: 2px solid #f0f0f0;
        }

        .compare-section.show {
            display: block;
        }

        .compare-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .compare-box {
            border: 3px dashed #667eea;
            border-radius: 12px;
            padding: 40px 20px;
            background: #f8f9ff;
            transition: all 0.3s ease;
            cursor: pointer;
            text-align: center;
        }

        .compare-box:hover {
            border-color: #764ba2;
            background: #f0f2ff;
            transform: translateY(-2px);
        }

        .compare-box.dragover {
            border-color: #764ba2;
            background: #e8ebff;
            transform: scale(1.02);
        }

        .compare-box.loaded {
            border-color: #27ae60;
            background: #e8f8f0;
        }

        .compare-box h3 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        .compare-box p {
            color: #666;
            font-size: 0.95em;
        }

        .compare-actions {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .diff-added {
            background: #e6ffed !important;
            border-left: 3px solid #28a745;
        }

        .diff-removed {
            background: #ffe6e6 !important;
            border-left: 3px solid #dc3545;
        }

        .diff-modified {
            background: #fff3cd !important;
            border-left: 3px solid #ffc107;
        }

        .diff-identical {
            opacity: 0.4;
        }

        .diff-header {
            background: #f8f9ff;
            padding: 15px 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            gap: 20px;
            align-items: center;
            justify-content: space-between;
        }

        .diff-legend {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }

        .diff-legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9em;
        }

        .diff-legend-box {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }

        .diff-legend-box.added {
            background: #e6ffed;
            border-color: #28a745;
        }

        .diff-legend-box.removed {
            background: #ffe6e6;
            border-color: #dc3545;
        }

        .diff-legend-box.modified {
            background: #fff3cd;
            border-color: #ffc107;
        }

        .diff-value-container {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .diff-value {
            flex: 1;
            min-width: 200px;
        }

        .diff-value-label {
            font-size: 0.8em;
            color: #666;
            font-weight: bold;
            margin-bottom: 4px;
        }

        .diff-filters {
            display: flex;
            gap: 10px;
        }

        .filter-btn {
            padding: 6px 12px;
            border: 1px solid #ddd;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.2s ease;
        }

        .filter-btn.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .filter-btn:hover {
            border-color: #667eea;
        }

        .upload-box {
            border: 3px dashed #667eea;
            border-radius: 12px;
            padding: 60px 40px;
            background: #f8f9ff;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .upload-box:hover {
            border-color: #764ba2;
            background: #f0f2ff;
            transform: translateY(-2px);
        }

        .upload-box.dragover {
            border-color: #764ba2;
            background: #e8ebff;
            transform: scale(1.02);
        }

        .upload-icon {
            font-size: 4em;
            margin-bottom: 20px;
        }

        .upload-box h2 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 1.5em;
        }

        .upload-box p {
            color: #666;
            font-size: 1.1em;
        }

        input[type="file"] {
            display: none;
        }

        .btn {
            display: inline-block;
            padding: 12px 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 1.1em;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.3s ease;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .file-info {
            background: #f8f9ff;
            padding: 15px 40px;
            border-bottom: 2px solid #f0f0f0;
            display: none;
        }

        .file-info.show {
            display: block;
        }

        .file-info p {
            color: #333;
            font-size: 1em;
        }

        .file-info strong {
            color: #667eea;
        }

        .tags-section {
            padding: 40px;
            display: none;
        }

        .tags-section.show {
            display: block;
        }

        .search-box {
            margin-bottom: 30px;
        }

        .search-box input {
            width: 100%;
            padding: 15px 20px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1em;
            transition: all 0.3s ease;
        }

        .search-box input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .tags-tree {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 20px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9em;
            overflow-x: auto;
        }

        .tag-line {
            padding: 6px 0;
            display: flex;
            align-items: baseline;
            transition: background 0.2s ease;
            border-radius: 4px;
            margin: 1px 0;
        }

        .tag-line:hover {
            background: #f8f9ff;
        }

        .tag-indent {
            display: inline-block;
            white-space: pre;
        }

        .tag-number {
            color: #667eea;
            font-weight: bold;
            min-width: 100px;
            display: inline-block;
        }

        .tag-vr {
            color: #888;
            min-width: 40px;
            display: inline-block;
            font-size: 0.85em;
        }

        .tag-name {
            color: #764ba2;
            font-weight: 600;
            min-width: 250px;
            display: inline-block;
        }

        .tag-value {
            color: #333;
            word-break: break-word;
            flex: 1;
        }

        .tag-value.empty {
            color: #999;
            font-style: italic;
        }

        .tag-value.binary {
            color: #e67e22;
        }

        .sequence-marker {
            color: #667eea;
            font-weight: bold;
        }

        .item-marker {
            color: #27ae60;
            font-weight: bold;
        }

        .collapse-btn {
            cursor: pointer;
            user-select: none;
            display: inline-block;
            width: 20px;
            text-align: center;
            margin-right: 5px;
            color: #667eea;
            font-weight: bold;
        }

        .collapse-btn:hover {
            color: #764ba2;
        }

        .collapsed-content {
            display: none;
        }

        .loading {
            text-align: center;
            padding: 40px;
            display: none;
        }

        .loading.show {
            display: block;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error {
            background: #fee;
            color: #c33;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 40px;
            display: none;
        }

        .error.show {
            display: block;
        }

        .footer {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px 30px 30px;
            margin-top: 20px;
        }

        .privacy-notice {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 25px;
            border-left: 4px solid #ffd700;
        }

        .privacy-notice h3 {
            font-size: 1.2em;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .privacy-notice p {
            line-height: 1.6;
            opacity: 0.95;
            margin-bottom: 8px;
        }

        .privacy-notice strong {
            color: #ffd700;
        }

        .copyright {
            text-align: center;
            padding-top: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            opacity: 0.9;
            font-size: 0.95em;
        }

        .copyright p {
            margin: 5px 0;
        }

        @media (max-width: 768px) {
            .tag-item {
                grid-template-columns: 1fr;
                gap: 5px;
            }

            .header h1 {
                font-size: 1.8em;
            }

            .upload-box {
                padding: 40px 20px;
            }

            .footer {
                padding: 30px 20px 20px;
            }

            .privacy-notice {
                padding: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>DICOM Viewer</h1>
            <p>Human Readable Dicom</p>
        </div>

        <div class="mode-switch">
            <button class="mode-btn active" id="singleModeBtn" onclick="switchMode('single')">Single File</button>
            <button class="mode-btn" id="compareModeBtn" onclick="switchMode('compare')">Compare Files</button>
        </div>

        <div class="upload-section" id="uploadSection">
            <div class="upload-box" id="uploadBox">
                <h2>Drag and drop your DICOM file</h2>
                <p>or click to select a file</p>
                <input type="file" id="fileInput" accept=".dcm,.dicom,*">
                <button class="btn" onclick="event.stopPropagation(); document.getElementById('fileInput').click()">
                    Choose a file
                </button>
            </div>
        </div>

        <div class="compare-section" id="compareSection">
            <div class="compare-grid">
                <div class="compare-box" id="compareBox1">
                    <h3>First DICOM File</h3>
                    <p id="file1Name">No file loaded</p>
                    <input type="file" id="fileInput1" accept=".dcm,.dicom,*" style="display: none;">
                    <button class="btn" onclick="event.stopPropagation(); document.getElementById('fileInput1').click()">
                        Choose File 1
                    </button>
                </div>
                <div class="compare-box" id="compareBox2">
                    <h3>Second DICOM File</h3>
                    <p id="file2Name">No file loaded</p>
                    <input type="file" id="fileInput2" accept=".dcm,.dicom,*" style="display: none;">
                    <button class="btn" onclick="event.stopPropagation(); document.getElementById('fileInput2').click()">
                        Choose File 2
                    </button>
                </div>
            </div>
            <div class="compare-actions">
                <button class="btn" id="compareBtn" onclick="compareDicoms()" style="display: none;">
                    Compare Files
                </button>
            </div>
        </div>

        <div class="file-info" id="fileInfo"></div>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>Loading and analyzing DICOM file...</p>
        </div>

        <div class="error" id="error"></div>

        <div class="tags-section" id="tagsSection">
            <div class="search-box">
                <input type="text" id="searchInput" placeholder="ðŸ” Search for a tag (name, number or value)...">
            </div>

            <div id="tagsContainer"></div>
        </div>

        <div class="footer">
            <div class="privacy-notice">
                <h3>ðŸ”’ Privacy & Security</h3>
                <p>
                    <strong>100% Serverless</strong> - All data stays on your device. Nothing is uploaded or stored externally.
                </p>
            </div>

            <div class="copyright">
                <p>&copy; Rochette Arthur - <a href="https://github.com/ArthurRochette/DicomViewer">github</a></p>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/dcmjs"></script>
    <script>
        const fileInput = document.getElementById('fileInput');
        const uploadBox = document.getElementById('uploadBox');
        const fileInfo = document.getElementById('fileInfo');
        const loading = document.getElementById('loading');
        const error = document.getElementById('error');
        const tagsSection = document.getElementById('tagsSection');
        const tagsContainer = document.getElementById('tagsContainer');
        const searchInput = document.getElementById('searchInput');

        let currentDicomData = null;
        let currentMode = 'single';

        // Compare mode variables
        let dicomFile1 = null;
        let dicomFile2 = null;
        let dicomData1 = null;
        let dicomData2 = null;
        const fileInput1 = document.getElementById('fileInput1');
        const fileInput2 = document.getElementById('fileInput2');
        const compareBox1 = document.getElementById('compareBox1');
        const compareBox2 = document.getElementById('compareBox2');
        const compareBtn = document.getElementById('compareBtn');
        const file1Name = document.getElementById('file1Name');
        const file2Name = document.getElementById('file2Name');
        let diffFilters = {
            added: true,
            removed: true,
            modified: true,
            identical: false
        };

        // Drag and drop
        uploadBox.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadBox.classList.add('dragover');
        });

        uploadBox.addEventListener('dragleave', () => {
            uploadBox.classList.remove('dragover');
        });

        uploadBox.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadBox.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });

        uploadBox.addEventListener('click', () => {
            fileInput.click();
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });

        // Debounce function to limit search frequency
        let searchTimeout;
        searchInput.addEventListener('input', (e) => {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                filterTags(e.target.value);
            }, 150);
        });

        async function handleFile(file) {
            try {
                // Reset UI
                error.classList.remove('show');
                tagsSection.classList.remove('show');
                loading.classList.add('show');

                // Display file info
                fileInfo.innerHTML = `
                    <p><strong>File:</strong> ${file.name}</p>
                    <p><strong>Size:</strong> ${formatFileSize(file.size)}</p>
                `;
                fileInfo.classList.add('show');

                // Read file
                const arrayBuffer = await file.arrayBuffer();
                const byteArray = new Uint8Array(arrayBuffer);

                // Parse DICOM
                const dataSet = dcmjs.data.DicomMessage.readFile(byteArray);
                const dict = dataSet.dict;

                currentDicomData = dict;

                console.log('DICOM Data:', dict);
                console.log('DICOM Dictionary:', dcmjs.data.DicomMetaDictionary.dictionary);

                // Debug: Test tag name retrieval
                const firstTag = Object.keys(dict)[0];
                if (firstTag) {
                    const formattedTag = `(${firstTag.substring(0, 4)},${firstTag.substring(4, 8)})`;
                    console.log('Sample tag:', firstTag, 'formatted:', formattedTag);
                    console.log('Dictionary entry:', dcmjs.data.DicomMetaDictionary.dictionary[formattedTag]);
                    console.log('Dictionary entry (raw):', dcmjs.data.DicomMetaDictionary.dictionary[firstTag]);
                }

                // Display tags
                displayTags(dict);

                loading.classList.remove('show');
                tagsSection.classList.add('show');

            } catch (err) {
                loading.classList.remove('show');
                error.textContent = `Error reading file: ${err.message}`;
                error.classList.add('show');
                console.error(err);
            }
        }

        function displayTags(dict) {
            // Display tags as tree
            tagsContainer.innerHTML = '';
            const treeDiv = document.createElement('div');
            treeDiv.className = 'tags-tree';

            const sortedTags = Object.keys(dict).sort();
            sortedTags.forEach(tag => {
                const lines = renderTag(tag, dict[tag], 0);
                treeDiv.innerHTML += lines;
            });

            tagsContainer.appendChild(treeDiv);
        }

        function renderTag(tag, tagData, level) {
            const indent = '  '.repeat(level);
            const tagNum = formatTag(tag);
            const vr = tagData.vr || 'UN';

            // Get tag name from dcmjs dictionary
            let tagName = getTagName(tag);

            let html = '';

            // Handle sequences
            if (vr === 'SQ' && tagData.Value && Array.isArray(tagData.Value)) {
                const itemCount = tagData.Value.length;
                const sequenceId = `seq_${tag}_${Math.random().toString(36).substr(2, 9)}`;

                html += `<div class="tag-line" data-search="${tagNum} ${tagName}">`;
                html += `<span class="tag-indent">${indent}</span>`;
                html += `<span class="collapse-btn" onclick="toggleCollapse('${sequenceId}', this)">â–¶</span>`;
                html += `<span class="tag-number">${tagNum}</span>`;
                html += `<span class="tag-vr">${vr}</span>`;
                html += `<span class="tag-name">${tagName}</span>`;
                html += `<span class="tag-value sequence-marker">[Sequence with ${itemCount} item(s)]</span>`;
                html += `</div>`;

                // Render sequence items - wrapped in collapsible div (collapsed by default)
                html += `<div id="${sequenceId}" class="collapsed-content">`;
                tagData.Value.forEach((item, index) => {
                    const itemId = `${sequenceId}_item_${index}`;

                    html += `<div class="tag-line" data-search="Item #${index + 1} ${tagName}">`;
                    html += `<span class="tag-indent">${'  '.repeat(level + 1)}</span>`;
                    html += `<span class="collapse-btn" onclick="toggleCollapse('${itemId}', this)">â–¶</span>`;
                    html += `<span class="item-marker">Item #${index + 1}:</span>`;
                    html += `</div>`;

                    // Item content - also collapsed by default
                    html += `<div id="${itemId}" class="collapsed-content">`;
                    const sortedSubTags = Object.keys(item).sort();
                    sortedSubTags.forEach(subTag => {
                        html += renderTag(subTag, item[subTag], level + 2);
                    });
                    html += `</div>`;
                });
                html += `</div>`;
            } else {
                // Regular tag
                const value = formatValue(tagData);
                const valueClass = !tagData.Value ? 'empty' : (vr === 'OB' || vr === 'OW' || vr === 'UN') ? 'binary' : '';

                html += `<div class="tag-line" data-search="${tagNum} ${tagName} ${value}">`;
                html += `<span class="tag-indent">${indent}</span>`;
                html += `<span class="tag-number">${tagNum}</span>`;
                html += `<span class="tag-vr">${vr}</span>`;
                html += `<span class="tag-name">${tagName}</span>`;
                html += `<span class="tag-value ${valueClass}">${value}</span>`;
                html += `</div>`;
            }

            return html;
        }

        function toggleCollapse(elementId, button) {
            const element = document.getElementById(elementId);
            if (element) {
                if (element.classList.contains('collapsed-content')) {
                    element.classList.remove('collapsed-content');
                    button.textContent = 'â–¼';
                } else {
                    element.classList.add('collapsed-content');
                    button.textContent = 'â–¶';
                }
            }
        }

        function formatTag(tag) {
            return `(${tag.substring(0, 4)},${tag.substring(4, 8)})`;
        }

        function getTagName(tag) {
            // Access the DicomMetaDictionary.dictionary from dcmjs
            const dicomDict = dcmjs.data.DicomMetaDictionary.dictionary;

            if (dicomDict) {
                // The tag format in dict might be with or without parentheses
                // Try with formatted tag like "(0010,0010)"
                const formattedTag = formatTag(tag);
                let entry = dicomDict[formattedTag];

                // If not found, try with the raw tag format
                if (!entry) {
                    entry = dicomDict[tag];
                }

                // The entry should be the tag name directly or an object with name property
                if (entry) {
                    if (typeof entry === 'string') {
                        return entry;
                    } else if (entry.name) {
                        return entry.name;
                    } else if (entry.keyword) {
                        return entry.keyword;
                    }
                }
            }

            return 'Unknown';
        }

        function formatValue(tagData) {
            if (!tagData.Value && tagData.Value !== 0) {
                return '[empty]';
            }

            const value = tagData.Value;
            const vr = tagData.vr;

            // Handle binary data
            if (vr === 'OB' || vr === 'OW' || vr === 'UN') {
                if (value instanceof Uint8Array || value instanceof ArrayBuffer) {
                    const length = value.byteLength || value.length;
                    return `[Binary data: ${length} bytes]`;
                }
            }

            // Handle arrays
            if (Array.isArray(value)) {
                if (value.length === 0) return '[empty]';
                if (vr === 'SQ') return '[Sequence]';

                // Limit array display
                if (value.length > 10) {
                    const preview = value.slice(0, 10).map(v => formatSingleValue(v, vr)).join(', ');
                    return `${preview}, ... (${value.length} values)`;
                }

                return value.map(v => formatSingleValue(v, vr)).join(', ');
            }

            return formatSingleValue(value, vr);
        }

        function formatSingleValue(value, vr) {
            if (value === null || value === undefined) return '';

            // Handle typed arrays
            if (value instanceof Uint8Array || value instanceof ArrayBuffer) {
                const length = value.byteLength || value.length;
                return `[Binary: ${length} bytes]`;
            }

            // Format numbers with appropriate precision
            if (typeof value === 'number') {
                if (vr === 'DS' || vr === 'FL' || vr === 'FD') {
                    return value.toFixed(6).replace(/\.?0+$/, '');
                }
                return String(value);
            }

            return String(value);
        }

        function getGroupName(groupId) {
            const groupNames = {
                '0002': 'File Meta Information',
                '0008': 'Identifying Information',
                '0010': 'Patient Information',
                '0018': 'Acquisition Information',
                '0020': 'Relationship Information',
                '0028': 'Image Presentation',
                '0032': 'Study Information',
                '0040': 'Procedure Information',
                '7FE0': 'Pixel Data'
            };
            return groupNames[groupId] || 'Other';
        }

        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(2) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
        }

        function filterTags(searchTerm) {
            const term = searchTerm.toLowerCase().trim();
            const tagLines = document.querySelectorAll('.tag-line');

            // Reset all if no search term
            if (!term) {
                tagLines.forEach(line => {
                    line.style.display = '';
                });
                return;
            }

            // Use requestAnimationFrame for better performance
            requestAnimationFrame(() => {
                // Build a map of lines and their collapse buttons for O(1) lookup
                const collapseButtons = new Map();
                document.querySelectorAll('.collapse-btn').forEach(btn => {
                    const onclickAttr = btn.getAttribute('onclick');
                    if (onclickAttr) {
                        const match = onclickAttr.match(/'([^']+)'/);
                        if (match) {
                            collapseButtons.set(match[1], btn);
                        }
                    }
                });

                const matchingLines = new Set();
                const containersToExpand = new Set();
                const linesToShow = new Set();

                // Single pass: identify matches and collect parent containers
                tagLines.forEach(line => {
                    const searchText = (line.dataset.search || '').toLowerCase();

                    if (searchText.includes(term)) {
                        matchingLines.add(line);
                        linesToShow.add(line);

                        // Walk up the DOM tree to find collapsed parents
                        let parent = line.parentElement;
                        while (parent && parent !== document.body) {
                            if (parent.classList.contains('collapsed-content')) {
                                containersToExpand.add(parent);
                                // Also mark the parent's header line as visible
                                const parentLine = parent.previousElementSibling;
                                if (parentLine && parentLine.classList.contains('tag-line')) {
                                    linesToShow.add(parentLine);
                                }
                            }
                            parent = parent.parentElement;
                        }
                    }
                });

                // Batch DOM updates
                const fragment = document.createDocumentFragment();

                // Expand containers (only those that need it)
                containersToExpand.forEach(container => {
                    if (container.classList.contains('collapsed-content')) {
                        container.classList.remove('collapsed-content');
                        // Update button using pre-built map
                        const btn = collapseButtons.get(container.id);
                        if (btn) {
                            btn.textContent = 'â–¼';
                        }
                    }
                });

                // Update visibility in a single pass
                tagLines.forEach(line => {
                    if (linesToShow.has(line)) {
                        line.style.display = '';
                    } else {
                        // Check if it's a parent of matching elements
                        const nextSibling = line.nextElementSibling;
                        let hasMatchingDescendant = false;

                        if (nextSibling && nextSibling.id && containersToExpand.has(nextSibling)) {
                            hasMatchingDescendant = true;
                        }

                        line.style.display = hasMatchingDescendant ? '' : 'none';
                    }
                });
            });
        }

        // Mode switching
        function switchMode(mode) {
            currentMode = mode;
            const uploadSection = document.getElementById('uploadSection');
            const compareSection = document.getElementById('compareSection');
            const singleModeBtn = document.getElementById('singleModeBtn');
            const compareModeBtn = document.getElementById('compareModeBtn');

            if (mode === 'single') {
                uploadSection.style.display = 'block';
                compareSection.classList.remove('show');
                singleModeBtn.classList.add('active');
                compareModeBtn.classList.remove('active');
                tagsSection.classList.remove('show');
            } else {
                uploadSection.style.display = 'none';
                compareSection.classList.add('show');
                singleModeBtn.classList.remove('active');
                compareModeBtn.classList.add('active');
                tagsSection.classList.remove('show');
            }

            error.classList.remove('show');
            loading.classList.remove('show');
        }

        // File input handlers for compare mode
        fileInput1.addEventListener('change', async (e) => {
            if (e.target.files.length > 0) {
                await handleCompareFile(e.target.files[0], 1);
            }
        });

        fileInput2.addEventListener('change', async (e) => {
            if (e.target.files.length > 0) {
                await handleCompareFile(e.target.files[0], 2);
            }
        });

        // Drag and drop for compare boxes
        [compareBox1, compareBox2].forEach((box, index) => {
            box.addEventListener('dragover', (e) => {
                e.preventDefault();
                box.classList.add('dragover');
            });

            box.addEventListener('dragleave', () => {
                box.classList.remove('dragover');
            });

            box.addEventListener('drop', async (e) => {
                e.preventDefault();
                box.classList.remove('dragover');
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    await handleCompareFile(files[0], index + 1);
                }
            });

            box.addEventListener('click', () => {
                if (index === 0) {
                    fileInput1.click();
                } else {
                    fileInput2.click();
                }
            });
        });

        async function handleCompareFile(file, fileNumber) {
            try {
                error.classList.remove('show');
                loading.classList.add('show');
                loading.innerHTML = '<div class="spinner"></div><p>Loading DICOM file ' + fileNumber + '...</p>';

                const arrayBuffer = await file.arrayBuffer();
                const byteArray = new Uint8Array(arrayBuffer);
                const dataSet = dcmjs.data.DicomMessage.readFile(byteArray);
                const dict = dataSet.dict;

                if (fileNumber === 1) {
                    dicomFile1 = file;
                    dicomData1 = dict;
                    file1Name.textContent = file.name;
                    compareBox1.classList.add('loaded');
                } else {
                    dicomFile2 = file;
                    dicomData2 = dict;
                    file2Name.textContent = file.name;
                    compareBox2.classList.add('loaded');
                }

                loading.classList.remove('show');

                // Show compare button if both files are loaded
                if (dicomData1 && dicomData2) {
                    compareBtn.style.display = 'inline-block';
                }

            } catch (err) {
                loading.classList.remove('show');
                error.textContent = `Error reading file ${fileNumber}: ${err.message}`;
                error.classList.add('show');
                console.error(err);
            }
        }

        function compareDicoms() {
            if (!dicomData1 || !dicomData2) {
                error.textContent = 'Please load both DICOM files first';
                error.classList.add('show');
                return;
            }

            error.classList.remove('show');
            loading.classList.add('show');
            loading.innerHTML = '<div class="spinner"></div><p>Comparing DICOM files...</p>';

            setTimeout(() => {
                try {
                    const diffs = computeDifferences(dicomData1, dicomData2);
                    displayComparison(diffs);
                    loading.classList.remove('show');
                    tagsSection.classList.add('show');
                } catch (err) {
                    loading.classList.remove('show');
                    error.textContent = `Error comparing files: ${err.message}`;
                    error.classList.add('show');
                    console.error(err);
                }
            }, 100);
        }

        function computeDifferences(dict1, dict2, level = 0) {
            const diffs = [];
            const allTags = new Set([...Object.keys(dict1), ...Object.keys(dict2)]);

            allTags.forEach(tag => {
                const tag1 = dict1[tag];
                const tag2 = dict2[tag];

                let diffType;
                let sequenceItems = null;

                if (!tag1) {
                    diffType = 'added'; // Only in file 2
                } else if (!tag2) {
                    diffType = 'removed'; // Only in file 1
                } else {
                    // Both exist, check if it's a sequence
                    const vr1 = tag1.vr;
                    const vr2 = tag2.vr;

                    if ((vr1 === 'SQ' || vr2 === 'SQ') && (tag1.Value || tag2.Value)) {
                        // It's a sequence, compare items
                        const items1 = tag1.Value || [];
                        const items2 = tag2.Value || [];

                        sequenceItems = compareSequenceItems(items1, items2, level + 1);

                        // Determine overall sequence diff type
                        if (items1.length !== items2.length) {
                            diffType = 'modified';
                        } else {
                            // Check if any item has differences
                            const hasAnyDiff = sequenceItems.some(item =>
                                item.diffs && item.diffs.some(d => d.type !== 'identical')
                            );
                            diffType = hasAnyDiff ? 'modified' : 'identical';
                        }
                    } else {
                        // Regular tag, compare values
                        const value1 = formatValue(tag1);
                        const value2 = formatValue(tag2);
                        diffType = (value1 === value2) ? 'identical' : 'modified';
                    }
                }

                diffs.push({
                    tag: tag,
                    type: diffType,
                    data1: tag1,
                    data2: tag2,
                    sequenceItems: sequenceItems,
                    level: level
                });
            });

            // Sort by tag number
            diffs.sort((a, b) => a.tag.localeCompare(b.tag));

            return diffs;
        }

        function compareSequenceItems(items1, items2, level) {
            const maxItems = Math.max(items1.length, items2.length);
            const itemComparisons = [];

            for (let i = 0; i < maxItems; i++) {
                const item1 = items1[i];
                const item2 = items2[i];

                let itemDiffType;
                let diffs = null;

                if (!item1) {
                    itemDiffType = 'added'; // Only in sequence 2
                } else if (!item2) {
                    itemDiffType = 'removed'; // Only in sequence 1
                } else {
                    // Both items exist, compare recursively
                    diffs = computeDifferences(item1, item2, level);

                    // Determine item diff type based on child diffs
                    const hasAnyDiff = diffs.some(d => d.type !== 'identical');
                    itemDiffType = hasAnyDiff ? 'modified' : 'identical';
                }

                itemComparisons.push({
                    index: i,
                    type: itemDiffType,
                    item1: item1,
                    item2: item2,
                    diffs: diffs
                });
            }

            return itemComparisons;
        }

        function displayComparison(diffs) {
            tagsContainer.innerHTML = '';

            // Create diff header with legend and filters
            const headerDiv = document.createElement('div');
            headerDiv.className = 'diff-header';
            headerDiv.innerHTML = `
                <div class="diff-legend">
                    <strong>Legend:</strong>
                    <div class="diff-legend-item">
                        <div class="diff-legend-box added"></div>
                        <span>Only in File 2</span>
                    </div>
                    <div class="diff-legend-item">
                        <div class="diff-legend-box removed"></div>
                        <span>Only in File 1</span>
                    </div>
                    <div class="diff-legend-item">
                        <div class="diff-legend-box modified"></div>
                        <span>Different Values</span>
                    </div>
                </div>
                <div class="diff-filters">
                    <button class="filter-btn ${diffFilters.removed ? 'active' : ''}" onclick="toggleDiffFilter('removed')">
                        Only in File 1
                    </button>
                    <button class="filter-btn ${diffFilters.added ? 'active' : ''}" onclick="toggleDiffFilter('added')">
                        Only in File 2
                    </button>
                    <button class="filter-btn ${diffFilters.modified ? 'active' : ''}" onclick="toggleDiffFilter('modified')">
                        Modified
                    </button>
                    <button class="filter-btn ${diffFilters.identical ? 'active' : ''}" onclick="toggleDiffFilter('identical')">
                        Identical
                    </button>
                </div>
            `;
            tagsContainer.appendChild(headerDiv);

            // Create tags tree
            const treeDiv = document.createElement('div');
            treeDiv.className = 'tags-tree';

            diffs.forEach(diff => {
                if (!diffFilters[diff.type]) return;

                const line = renderComparisonTag(diff);
                treeDiv.innerHTML += line;
            });

            tagsContainer.appendChild(treeDiv);
        }

        function renderComparisonTag(diff) {
            const tagNum = formatTag(diff.tag);
            const tagName = getTagName(diff.tag);
            const indent = '  '.repeat(diff.level || 0);
            let diffClass = '';
            let html = '';

            switch (diff.type) {
                case 'added':
                    diffClass = 'diff-added';
                    break;
                case 'removed':
                    diffClass = 'diff-removed';
                    break;
                case 'modified':
                    diffClass = 'diff-modified';
                    break;
                case 'identical':
                    diffClass = 'diff-identical';
                    break;
            }

            const vr1 = diff.data1?.vr || '';
            const vr2 = diff.data2?.vr || '';
            const vr = vr1 || vr2;

            // Check if it's a sequence
            if (vr === 'SQ' && diff.sequenceItems) {
                const sequenceId = `seq_diff_${diff.tag}_${Math.random().toString(36).substr(2, 9)}`;
                const items1Count = diff.data1?.Value?.length || 0;
                const items2Count = diff.data2?.Value?.length || 0;

                html += `<div class="tag-line ${diffClass}" data-search="${tagNum} ${tagName}">`;
                html += `<span class="tag-indent">${indent}</span>`;
                html += `<span class="collapse-btn" onclick="toggleCollapse('${sequenceId}', this)">â–¶</span>`;
                html += `<span class="tag-number">${tagNum}</span>`;
                html += `<span class="tag-vr">${vr}</span>`;
                html += `<span class="tag-name">${tagName}</span>`;

                if (diff.type === 'added') {
                    html += `<span class="tag-value sequence-marker">[Sequence: ${items2Count} item(s) - Only in File 2]</span>`;
                } else if (diff.type === 'removed') {
                    html += `<span class="tag-value sequence-marker">[Sequence: ${items1Count} item(s) - Only in File 1]</span>`;
                } else if (diff.type === 'modified') {
                    html += `<span class="tag-value sequence-marker">[Sequence: File 1 has ${items1Count} item(s), File 2 has ${items2Count} item(s)]</span>`;
                } else {
                    html += `<span class="tag-value sequence-marker">[Sequence: ${items1Count} item(s) - Identical]</span>`;
                }

                html += `</div>`;

                // Render sequence items (collapsed by default)
                html += `<div id="${sequenceId}" class="collapsed-content">`;
                diff.sequenceItems.forEach(itemComp => {
                    html += renderSequenceItemComparison(itemComp, diff.level + 1, tagName);
                });
                html += `</div>`;

            } else {
                // Regular tag
                html += `<div class="tag-line ${diffClass}" data-search="${tagNum} ${tagName}">`;
                html += `<span class="tag-indent">${indent}</span>`;
                html += `<span class="tag-number">${tagNum}</span>`;
                html += `<span class="tag-vr">${vr}</span>`;
                html += `<span class="tag-name">${tagName}</span>`;

                if (diff.type === 'modified') {
                    const value1 = formatValue(diff.data1);
                    const value2 = formatValue(diff.data2);
                    html += `<div class="diff-value-container">`;
                    html += `<div class="diff-value">`;
                    html += `<div class="diff-value-label">File 1:</div>`;
                    html += `<span class="tag-value">${value1}</span>`;
                    html += `</div>`;
                    html += `<div class="diff-value">`;
                    html += `<div class="diff-value-label">File 2:</div>`;
                    html += `<span class="tag-value">${value2}</span>`;
                    html += `</div>`;
                    html += `</div>`;
                } else if (diff.type === 'added') {
                    const value2 = formatValue(diff.data2);
                    html += `<span class="tag-value">${value2}</span>`;
                } else if (diff.type === 'removed') {
                    const value1 = formatValue(diff.data1);
                    html += `<span class="tag-value">${value1}</span>`;
                } else {
                    const value = formatValue(diff.data1 || diff.data2);
                    html += `<span class="tag-value">${value}</span>`;
                }

                html += `</div>`;
            }

            return html;
        }

        function renderSequenceItemComparison(itemComp, level, parentName) {
            const indent = '  '.repeat(level);
            const itemId = `item_diff_${itemComp.index}_${Math.random().toString(36).substr(2, 9)}`;
            let html = '';
            let diffClass = '';

            switch (itemComp.type) {
                case 'added':
                    diffClass = 'diff-added';
                    break;
                case 'removed':
                    diffClass = 'diff-removed';
                    break;
                case 'modified':
                    diffClass = 'diff-modified';
                    break;
                case 'identical':
                    diffClass = 'diff-identical';
                    break;
            }

            html += `<div class="tag-line ${diffClass}" data-search="Item #${itemComp.index + 1} ${parentName}">`;
            html += `<span class="tag-indent">${indent}</span>`;
            html += `<span class="collapse-btn" onclick="toggleCollapse('${itemId}', this)">â–¶</span>`;
            html += `<span class="item-marker">Item #${itemComp.index + 1}`;

            if (itemComp.type === 'added') {
                html += ` (Only in File 2)`;
            } else if (itemComp.type === 'removed') {
                html += ` (Only in File 1)`;
            } else if (itemComp.type === 'modified') {
                html += ` (Modified)`;
            }

            html += `</span></div>`;

            // Item content (collapsed by default)
            html += `<div id="${itemId}" class="collapsed-content">`;

            if (itemComp.diffs) {
                // Render child tags
                itemComp.diffs.forEach(childDiff => {
                    html += renderComparisonTag(childDiff);
                });
            } else if (itemComp.item1) {
                // Only in file 1 - show all tags from item1
                const sortedTags = Object.keys(itemComp.item1).sort();
                sortedTags.forEach(tag => {
                    html += renderComparisonTag({
                        tag: tag,
                        type: 'removed',
                        data1: itemComp.item1[tag],
                        data2: null,
                        level: level + 1
                    });
                });
            } else if (itemComp.item2) {
                // Only in file 2 - show all tags from item2
                const sortedTags = Object.keys(itemComp.item2).sort();
                sortedTags.forEach(tag => {
                    html += renderComparisonTag({
                        tag: tag,
                        type: 'added',
                        data1: null,
                        data2: itemComp.item2[tag],
                        level: level + 1
                    });
                });
            }

            html += `</div>`;

            return html;
        }

        function toggleDiffFilter(filterType) {
            diffFilters[filterType] = !diffFilters[filterType];

            // Re-render comparison with new filters
            if (dicomData1 && dicomData2) {
                const diffs = computeDifferences(dicomData1, dicomData2);
                displayComparison(diffs);
            }
        }
    </script>
</body>
</html>
